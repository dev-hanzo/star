---
title: Практическое занятие "Используем клиент GitHub для десктопа"
last_updated: Oct 10, 2019
sidebar: mydoc_sidebar
permalink: Use-GitHub-Desktop.html
folder: publishing-doc
---


Хотя большинство разработчиков используют командную строку при работе с системами контроля версий, существует много доступных клиентов с графическим интерфейсом, которые потенциально могут упростить процесс. Такие инструменты могут быть полезны, когда нужно увидеть, что изменилось в файле, поскольку графический интерфейс пользователя может быстро выделить и указать на происходящие изменения.

<a name="workflow"></a>
## Типичный процесс использования десктопного клиента

В этом разделе мы научимся использовать десктопный клиент GitHub для управления процессом Git.

{% include note.html content="Вместо работы в Wiki GitHub (как делали в [предыдущем разделе по GitHub](Manage-wiki-content.html) ), будем работать в обычном Git-репозитории. В Wiki GitHub есть некоторые ограничения, когда дело касается отправки запросов." %}

Для настройки репозитория Git используя клиента GitHub Desktop:

- Скачаем и установим [GitHub Desctop](https://desktop.github.com/). Запускам приложение и авторизуемся. (По идее у нас уже есть аккаунт на GitHub, но есть нет, то создаем его).
- Заходим на страницу [github.com](https://github.com/) и ищем наш репозиторий, созданный в предыдущем разделе. Открываем именно репозиторий, а не страницу Wiki. (Если не практические занятия из прошлого раздела не сделаны, то создаем новый репозиторий).
- Нажимаем кнопку `Clone or download` и выбираем `Open on desktop`

{% include image.html file="publishing-doc/34.png" alt="desktop" caption="Кнопка Onen in Desktop" %}

- Открываем приложение GitHub Desktop и переходим в `File > Clone Repository`.
- В диалоговом окне выбираем **Open GitHub Desktop.app**. GitHub Desktop должен запуститься с диалоговым окном «Клонировать репозиторий», содержащим запрос, где клонировать репозиторий. При желании локальный путь можно изменить.
- Переходим на вкладку **URL** и вставляем URL-адрес клона. В поле **Local Path** выбираем, куда клонировать репозиторий. Например:

{% include image.html file="publishing-doc/35.png" alt="desktop" caption="Выбор адреса клонирования репозитория" %}

- Нажимаем `Clone`
- Переходим в клонированный репозиторий и, либо добавляем простой текстовый файл с некоторым содержимым, либо вносим изменения в существующий файл.
- Возвращаемся в GitHub Desktop. Видим, что новый файл добавлен список незафиксированных изменений в левой колонке.

{% include image.html file="publishing-doc/36.png" alt="desktop" caption="Незафиксированные изменения" %}

В списке измененных файлов зеленый знак `+` означает добавление нового файла. Желтый круг означает изменения существующего файла.

- В левом нижнем углу клиента GitHub Desktop (где написано Summary и Description) вводим описание коммита и кликаем **Commit to master**.

Когда мы фиксируем изменения, на левой панели исчезает список незафиксированных изменений. Однако изменения мы зафиксировали только локально. Коммит еще нужно отправить в удаленный (origin) репозиторий. («Origin» - это псевдоним, который относится к удаленному хранилищу.)

- Наверху кликаем Push origin

{% include image.html file="publishing-doc/37.png" alt="desktop" max-width="231" %}

Если посмотреть репозиторий в сети, то увидим, что внесенные изменения были перенесены в основную ветку в источнике. Можно перейти на вкладку **History** в клиенте GitHub Desktop (вместо вкладки **Changes**) или перейти в меню **View > Show History**, чтобы просмотреть ранее внесенные изменения.

{% include note.html content="Многие предпочитают использовать терминал вместо графического интерфейса GitHub для рабочего стола, графический интерфейс упрощает визуальное восприятие изменений, внесенных в репозиторий. При желании можно комбинировать использование командной строки и клиента рабочего стола." %}

<a name="create"></a>
## Создание ветки

Теперь создадим ветку, внесем изменения и посмотрим как влияют изменения на ветку.

- В GitHub Desktop переходим в **Branch > New Branch** и создаем новую ветвь. Назовем ее «development» и нажмем **Create Branch**.

{% include image.html file="publishing-doc/38.png" alt="desktop" caption="Создание новой ветки" %}

После создания ветки, в центре раскрывающееся меню будет указывать на ту ветку, в которой мы работаем. Создание ветки копирует существующий контент (из ветки master) в новую ветку (development).

{% include image.html file="publishing-doc/39.png" alt="desktop" caption="Работа с ветками" %}

- Откроем файл, которые ранее создали и внесем в него изменения, например добавим новую строку с текстом. Сохраним изменения.
- Вернемся в GitHub Desktop и обратим внимание, что на вкладке «Changes» у нас появились новые измененные файлы.

{% include image.html file="publishing-doc/40.png" alt="desktop" %}

Изменения в файле показывают удаленные строки красным и новые строки зеленым цветом. Цвета помогают увидеть, что изменилось.

- Закоммитим изменения в левом нижнем углу и кликнем на **Commit to development**.
- Нажимаем **Publish branch** (в верхней части окна GitHub Desktop), чтобы сделать локальную ветку также доступной в Origin (GitHub). (Всегда существует две версии ветки: локальная версия и удаленная версия.)
- Вернемся в основную ветку (выбираем master в раскрывающемся меню). Затем посмотрим на свой файл (в текстовом редакторе). Стоит обратить внимание, что изменения, внесенные нами во время редактирования в ветке `development`, не отображаются в основной ветке.

Обычно новую ветку создают, когда вносят значительные изменения в контент. Например, нужно обновить раздел («Раздел X») в своих документах. Возможно, опубликовать другие обновления не нужно, прежде чем публиковать подробные изменения в Разделе X. Если работа была в той же ветке, было бы сложно выборочно загружать обновления для нескольких файлов за пределами Раздела X без отправки обновлений, которые сделали к файлам в разделе Х.

Посредством ветвления можно ограничить свои изменения конкретной версией, которая не запускается, пока не будут готовы изменения к объединению с master веткой.

<a name="merge"></a>
## Слияние (merge) ветки development с master

Теперь научимся объединять наши ветки.

- В GitHub Desktop переключитесь на ветку, в которую вы хотите объединить ветку development. В селекторе веток выберите ветку master.
- Переходим **Branch > Merge into Current Branch**
- В окне слияния выбираем ветку development и кликаем **Merge development into master**

{% include image.html file="publishing-doc/41.png" alt="desktop" caption="Merge в ветку master" %}

После слияния веток изменения будут отображаться и в файле в ветке master.

- Нажимаем **Push origin** для отправки изменений в удаленный репозиторий.

После этого наши изменения будут отображены в репозитории на GitHub.

<a name="merge-request"></a>
## Слияние ветки через pull request

Теперь объединим ветку development с master, используя процесс pull request. Мы притворимся, что клонировали репозиторий разработчика, и хотим, чтобы разработчик влил наше изменение в ветку development. (Другими словами, у нас может нет прав на слияние веток в мастер.) Для этого мы создадим запрос на извлечение (pull request).

- Как выше, переключаемся на ветку development, вносим изменения в содержимое файла, сохраняем и подтверждаем изменения. После внесения изменений нажимаем **Push origin**, чтобы отправить наши изменения в удаленную версию ветки разработки на GitHub.
- В GitHub Desktop, с выбранной веткой development, переходим в **Branch > Create Pull Request**.

На сайте GiHub pull request выглядит так:

{% include image.html file="publishing-doc/42.png" alt="desktop" caption="Pull Request" %}

Стрелка влево (указывающая из ветви development в направлении master) указывает, что запрос на извлечение («PR») хочет объединить ветку development с основной веткой.

- Напишем причину запроса на извлечение и нажмем **Create pull request**.
- На этом этапе разработчики получат запрос по электронной почте с просьбой объединить их изменения. Попробуем себя в роли разработчика, перейдя на вкладку **Pull requests** (на GitHub), чтобы проверить и подтвердить запрос. Пока запрос на слияние не вызывает конфликтов, видна кнопка **Merge pull request**.

{% include image.html file="publishing-doc/43.png" alt="desktop" caption="Подтверждение запроса" %}

- Чтобы увидеть, какие изменения объединяются с мастером, можете щелкнуть вкладку **Files changed** (которая появляется на дополнительной навигационной панели вверху). Затем кликаем **Merge pull request** для объединения в ветке и **Confirm merge**, чтобы завершить объединение.

- Теперь получим обновления, которые мы слили в `master` ветку, в свою локальную копию. В GitHub Desktop выбираем `master` ветку и кликаем кнопку **Fetch origin**. Fetch получает последние обновления из источника, но не обновляет локальную рабочую копию с изменениями.

После нажатия кнопка **Fetch origin** изменится на **Pull Origin**.

- Нажимаем на **Pull Origin** чтобы обновить локальную копию с полученными изменениями.

Проверим файлы и обратим внимание, что обновления, которые изначально были в ветке development, теперь отображаются и в master.

{% include note.html content="Более подробное руководство по созданию запросов извлечения с использованием интерфейса GitHub см. В разделе [Процесс Pull request на GitHub](Pull-request-workflows.html). Работать с Pull Request нужно уметь, если  планируется участие в [опен-сорс проектах](find-open-source-project.html)." %}

<a name="manage"></a>
## Управление конфликтами слияния

Предположим, мы внесли изменения в свою локальную копию файла в хранилище, а кто-то другой изменяет этот же файл, используя интерфейс браузера [GitHub.com](https://github.com/). Изменения противоречат друг другу. Что происходит?

Когда нажимаем **Push origin** от клиента GitHub Desktop, увидим сообщение о том, что хранилище было обновлено с момента последнего извлечения:

```
“The repository has been updated since you last pulled. Try pulling before pushing.”
```

Кнопка, которая раньше говорила «Push origin», теперь говорит «Pull origin». кликаем «Pull origin». Теперь получаем еще одно сообщение об ошибке, которое говорит:

```
“We found some conflicts while trying to merge. Please resolve the conflicts and commit the changes.”
```

Если решим зафиксировать свои изменения, то увидим сообщение, которое гласит:

```
“Please resolve all conflicted files, commit, and then try syncing again.”
```

GitHub Desktop отображает восклицательный знак рядом с файлами с конфликтами слияния. Откройте файл конфликта и найдите маркеры конфликта (`<<<<<<<` и `>>>>>>>`). Например, такие:

```
<<<<<<< HEAD
This is an edit I made locally.
=======
This is an edit I made from the browser.
>>>>>>> c163ead57f6793678dd41b5efeef372d9bd81035
```

В командной строке можно запустить `git status`, чтобы увидеть, какие файлы имеют конфликты.) Содержимое в `HEAD` показывает локальные изменения. Содержание ниже `=======` показывает изменения, внесенные в другом месте.

Устраняем все конфликты, изменив содержимое маркеров, а затем удалив маркеры. Например, обновите содержимое до этого:

```
This is an edit I made locally.
```

Теперь нужно снова добавить файл в Git. В GitHub Desktop внесем изменения в обновленные файлы. Кликаем **Push origin**. Обновления на локальном компьютере отправляются на удаленный компьютер без каких-либо конфликтов.

<a name="conclusion"></a>
## Заключение

Чем больше использовать GitHub, тем больше опыта работы с нужными рабочими процессами. Git - это мощная платформа для совместной работы, в которой есть множество команд, рабочих процессов и функций, которые можно использовать для различных сценариев. Несмотря на разнообразие команд и рабочих процессов Git, наиболее используемые сценарии ограничены по объему и доступны для изучения без особых усилий. Довольно скоро такие рабочие процессы станут автоматическими.

Используемые в этом занятии команды в интерфейсе GitHub Desktop можно попробовать и в командной строке. Возможно, что командная строка понравится больше. Но GitHub Desktop может стать хорошей отправной точкой.

[🔙](Manage-wiki-content.html)

[Go next ➡](Pull-request-workflows.html)
